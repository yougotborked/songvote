// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fetchCandidatesByRD = `-- name: FetchCandidatesByRD :many
SELECT s.id, s.title, sr.rating, sr.rd
FROM song s
JOIN song_rating sr ON s.id = sr.song_id
WHERE sr.rating BETWEEN $1 AND $2
ORDER BY sr.rd DESC
LIMIT $3
`

type FetchCandidatesByRDParams struct {
	Rating   float64 `json:"rating"`
	Rating_2 float64 `json:"rating_2"`
	Limit    int32   `json:"limit"`
}

type FetchCandidatesByRDRow struct {
	ID     int32   `json:"id"`
	Title  string  `json:"title"`
	Rating float64 `json:"rating"`
	Rd     float64 `json:"rd"`
}

func (q *Queries) FetchCandidatesByRD(ctx context.Context, arg FetchCandidatesByRDParams) ([]FetchCandidatesByRDRow, error) {
	rows, err := q.db.Query(ctx, fetchCandidatesByRD, arg.Rating, arg.Rating_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchCandidatesByRDRow
	for rows.Next() {
		var i FetchCandidatesByRDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Rating,
			&i.Rd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLeastSeenSongs = `-- name: FetchLeastSeenSongs :many
SELECT s.id, s.title, COALESCE(b.cnt, 0) AS seen
FROM song s
LEFT JOIN (
    SELECT unnest(song_ids) AS song_id, count(*) AS cnt
    FROM ballot_send
    WHERE participant_id = $1 AND sent_at >= now() - interval '14 days'
    GROUP BY song_id
) b ON s.id = b.song_id
ORDER BY COALESCE(b.cnt,0) ASC, s.id ASC
LIMIT $2
`

type FetchLeastSeenSongsParams struct {
	ParticipantID int32 `json:"participant_id"`
	Limit         int32 `json:"limit"`
}

type FetchLeastSeenSongsRow struct {
	ID    int32  `json:"id"`
	Title string `json:"title"`
	Seen  int64  `json:"seen"`
}

func (q *Queries) FetchLeastSeenSongs(ctx context.Context, arg FetchLeastSeenSongsParams) ([]FetchLeastSeenSongsRow, error) {
	rows, err := q.db.Query(ctx, fetchLeastSeenSongs, arg.ParticipantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchLeastSeenSongsRow
	for rows.Next() {
		var i FetchLeastSeenSongsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Seen); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipant = `-- name: GetParticipant :one
SELECT id, name, phone_e164, created_at
FROM participant
WHERE id = $1
`

func (q *Queries) GetParticipant(ctx context.Context, id int32) (Participant, error) {
	row := q.db.QueryRow(ctx, getParticipant, id)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneE164,
		&i.CreatedAt,
	)
	return i, err
}

const getSong = `-- name: GetSong :one
SELECT id, title, youtube_id, created_at
FROM song
WHERE id = $1
`

func (q *Queries) GetSong(ctx context.Context, id int32) (Song, error) {
	row := q.db.QueryRow(ctx, getSong, id)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.YoutubeID,
		&i.CreatedAt,
	)
	return i, err
}

const insertBallotSend = `-- name: InsertBallotSend :one
INSERT INTO ballot_send (participant_id, song_ids)
VALUES ($1, $2)
RETURNING id, participant_id, song_ids, sent_at
`

type InsertBallotSendParams struct {
	ParticipantID int32   `json:"participant_id"`
	SongIds       []int32 `json:"song_ids"`
}

func (q *Queries) InsertBallotSend(ctx context.Context, arg InsertBallotSendParams) (BallotSend, error) {
	row := q.db.QueryRow(ctx, insertBallotSend, arg.ParticipantID, arg.SongIds)
	var i BallotSend
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.SongIds,
		&i.SentAt,
	)
	return i, err
}

type InsertPairwiseResultsParams struct {
	Winner    int32              `json:"winner"`
	Loser     int32              `json:"loser"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

const insertParticipant = `-- name: InsertParticipant :one
INSERT INTO participant (name, phone_e164)
VALUES ($1, $2)
RETURNING id, name, phone_e164, created_at
`

type InsertParticipantParams struct {
	Name      string `json:"name"`
	PhoneE164 string `json:"phone_e164"`
}

func (q *Queries) InsertParticipant(ctx context.Context, arg InsertParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, insertParticipant, arg.Name, arg.PhoneE164)
	var i Participant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PhoneE164,
		&i.CreatedAt,
	)
	return i, err
}

const insertSMSInbound = `-- name: InsertSMSInbound :one
INSERT INTO sms_inbound (participant_id, body)
VALUES ($1, $2)
RETURNING id, participant_id, body, received_at
`

type InsertSMSInboundParams struct {
	ParticipantID pgtype.Int4 `json:"participant_id"`
	Body          string      `json:"body"`
}

func (q *Queries) InsertSMSInbound(ctx context.Context, arg InsertSMSInboundParams) (SmsInbound, error) {
	row := q.db.QueryRow(ctx, insertSMSInbound, arg.ParticipantID, arg.Body)
	var i SmsInbound
	err := row.Scan(
		&i.ID,
		&i.ParticipantID,
		&i.Body,
		&i.ReceivedAt,
	)
	return i, err
}

const insertSong = `-- name: InsertSong :one
INSERT INTO song (title, youtube_id)
VALUES ($1, $2)
RETURNING id, title, youtube_id, created_at
`

type InsertSongParams struct {
	Title     string `json:"title"`
	YoutubeID string `json:"youtube_id"`
}

func (q *Queries) InsertSong(ctx context.Context, arg InsertSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, insertSong, arg.Title, arg.YoutubeID)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.YoutubeID,
		&i.CreatedAt,
	)
	return i, err
}

const leaderboard = `-- name: Leaderboard :many
SELECT s.id, s.title, sr.rating, sr.rd
FROM song s
JOIN song_rating sr ON s.id = sr.song_id
ORDER BY sr.rating DESC, sr.rd ASC, s.title ASC
`

type LeaderboardRow struct {
	ID     int32   `json:"id"`
	Title  string  `json:"title"`
	Rating float64 `json:"rating"`
	Rd     float64 `json:"rd"`
}

func (q *Queries) Leaderboard(ctx context.Context) ([]LeaderboardRow, error) {
	rows, err := q.db.Query(ctx, leaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeaderboardRow
	for rows.Next() {
		var i LeaderboardRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Rating,
			&i.Rd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSongRating = `-- name: UpsertSongRating :one
INSERT INTO song_rating (song_id, rating, rd)
VALUES ($1, $2, $3)
ON CONFLICT (song_id)
DO UPDATE SET rating = EXCLUDED.rating, rd = EXCLUDED.rd
RETURNING song_id, rating, rd
`

type UpsertSongRatingParams struct {
	SongID int32   `json:"song_id"`
	Rating float64 `json:"rating"`
	Rd     float64 `json:"rd"`
}

func (q *Queries) UpsertSongRating(ctx context.Context, arg UpsertSongRatingParams) (SongRating, error) {
	row := q.db.QueryRow(ctx, upsertSongRating, arg.SongID, arg.Rating, arg.Rd)
	var i SongRating
	err := row.Scan(&i.SongID, &i.Rating, &i.Rd)
	return i, err
}
